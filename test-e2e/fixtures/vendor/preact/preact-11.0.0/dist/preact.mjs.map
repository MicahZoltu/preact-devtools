{"version":3,"file":"preact.mjs","sources":["../src/constants.js","../src/options.js","../src/diff/catch-error.js","../src/diff/commit.js","../src/create-element.js","../src/diff/refs.js","../src/diff/props.js","../src/diff/component.js","../src/create-context.js","../src/diff/unmount.js","../src/diff/children.js","../src/diff/patch.js","../src/component.js","../src/tree.js","../src/diff/mount.js","../src/create-root.js","../src/render.js","../src/clone-element.js","../src/create-portal.js"],"sourcesContent":["// Internal.flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n/** Signals the component can skip children due to a non-update */\nexport const SKIP_CHILDREN = 1 << 15;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE |\n\tSKIP_CHILDREN\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import {\n\tDIRTY_BIT,\n\tMODE_RERENDERING_ERROR,\n\tMODE_PENDING_ERROR,\n\tTYPE_COMPONENT\n} from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').Internal} internal The Internal node that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, internal) {\n\twhile ((internal = internal._parent)) {\n\t\tif (\n\t\t\tinternal.flags & TYPE_COMPONENT &&\n\t\t\t~internal.flags & MODE_RERENDERING_ERROR\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (internal.type.getDerivedStateFromError) {\n\t\t\t\t\tinternal._component.setState(\n\t\t\t\t\t\tinternal.type.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (internal._component.componentDidCatch) {\n\t\t\t\t\tinternal._component.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\t// NOTE: We're checking that any component in the stack got marked as dirty, even if it did so prior to this loop,\n\t\t\t\t// which is technically incorrect. However, there is no way for a component to mark itself as dirty during rendering.\n\t\t\t\t// The only way for a component to falsely intercept error bubbling would be to manually sets its internal dirty flag.\n\t\t\t\tif (internal.flags & DIRTY_BIT) {\n\t\t\t\t\tinternal.flags |= MODE_PENDING_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import options from '../options';\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {() => void} callback\n */\nexport function addCommitCallback(internal, callback) {\n\tif (internal._commitCallbacks == null) {\n\t\tinternal._commitCallbacks = [];\n\t}\n\n\tinternal._commitCallbacks.push(callback);\n}\n\n/**\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').Internal} rootInternal\n */\nexport function commitRoot(commitQueue, rootInternal) {\n\tif (options._commit) options._commit(rootInternal, commitQueue);\n\n\tcommitQueue.some(internal => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the root variable here so the type changes\n\t\t\tcommitQueue = internal._commitCallbacks.length;\n\t\t\t// @ts-ignore See above ts-ignore comment\n\t\t\twhile (commitQueue--) {\n\t\t\t\tinternal._commitCallbacks.shift()();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n}\n","import { UNDEFINED } from './constants';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, 0);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tconstructor: undefined,\n\t\t_vnodeId: original || ++vnodeId\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\n/**\n * @param {import('./internal').ComponentChildren} childVNode\n * @returns {import('./internal').VNode | string | null}\n */\nexport function normalizeToVNode(childVNode) {\n\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\treturn null;\n\t}\n\n\tif (typeof childVNode === 'object') {\n\t\treturn Array.isArray(childVNode)\n\t\t\t? createVNode(Fragment, { children: childVNode }, null, null, 0)\n\t\t\t: childVNode;\n\t}\n\n\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t// it's own DOM & etc. pointers\n\treturn typeof childVNode === 'function' ? childVNode : childVNode + '';\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === UNDEFINED;\n","import options from '../options';\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').Internal} internal\n */\nexport function applyRef(oldRef, ref, value, internal) {\n\tif (oldRef === ref) return;\n\n\tif (oldRef) applyRef(null, oldRef, null, internal);\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse if (ref) ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, internal);\n\t}\n}\n","import options from '../options';\n\nfunction setStyle(dom, key, value) {\n\tif (key[0] === '-') {\n\t\tdom.style.setProperty(key, value);\n\t} else {\n\t\tdom.style[key] = value == null ? '' : value;\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {number} isSvg 0 if not an SVG element, else it is an SVG element\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tsetStyle(dom, 'cssText', value);\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tsetStyle(dom, 'cssText', (oldValue = ''));\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!value || !(name in value)) {\n\t\t\t\t\t\tsetStyle(dom, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (name in value) {\n\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\tsetStyle(dom, name, value[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n\tif (this._isControlled) {\n\t\tif (this.value != null && (e.type === 'input' || e.type === 'change')) {\n\t\t\tthis.value = this._prevValue;\n\t\t}\n\t\tif (this.checked != null && e.type === 'change') {\n\t\t\tthis.checked = this._prevValue;\n\t\t}\n\t}\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import options from '../options';\nimport { DIRTY_BIT, FORCE_UPDATE, SKIP_CHILDREN } from '../constants';\nimport { addCommitCallback } from './commit';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @returns {import('../index').ComponentChild} pointer to the next DOM node (in order) to be rendered (or null)\n */\nexport function renderFunctionComponent(\n\tnewVNode,\n\tinternal,\n\tcontext,\n\tcomponentContext\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet tmp;\n\n\t/** @type {import('../internal').ComponentType} */\n\tlet type = (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (internal && internal._component) {\n\t\tc = internal._component;\n\t} else {\n\t\tinternal._component = c = {\n\t\t\tprops: newProps,\n\t\t\tcontext: componentContext,\n\t\t\tforceUpdate: internal.rerender.bind(null, internal)\n\t\t};\n\n\t\tinternal.flags |= DIRTY_BIT;\n\t}\n\n\tif (newVNode && newVNode._vnodeId === internal._vnodeId) {\n\t\tc.props = newProps;\n\t\tinternal.flags |= SKIP_CHILDREN;\n\t\treturn;\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\n\tif ((tmp = options._render)) tmp(internal);\n\n\tinternal.flags &= ~DIRTY_BIT;\n\tc._internal = internal;\n\n\ttmp = type.call(c, c.props, c.context);\n\n\tif (c.getChildContext != null) {\n\t\tinternal._context = Object.assign({}, context, c.getChildContext());\n\t}\n\n\treturn tmp;\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @returns {import('../index').ComponentChild} pointer to the next DOM node (in order) to be rendered (or null)\n */\nexport function renderClassComponent(\n\tnewVNode,\n\tinternal,\n\tcontext,\n\tcomponentContext\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet isNew, oldProps, oldState, snapshot, tmp;\n\n\t/** @type {import('../internal').ComponentType} */\n\tlet type = (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (internal && internal._component) {\n\t\tc = internal._component;\n\t} else {\n\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\tinternal._component = c = new type(newProps, componentContext); // eslint-disable-line new-cap\n\n\t\tif (!c.state) c.state = {};\n\t\tisNew = true;\n\t\tinternal.flags |= DIRTY_BIT;\n\t}\n\n\t// Invoke getDerivedStateFromProps\n\tif (c._nextState == null) {\n\t\tc._nextState = c.state;\n\t}\n\tif (type.getDerivedStateFromProps != null) {\n\t\tif (c._nextState == c.state) {\n\t\t\tc._nextState = Object.assign({}, c._nextState);\n\t\t}\n\n\t\tObject.assign(\n\t\t\tc._nextState,\n\t\t\ttype.getDerivedStateFromProps(newProps, c._nextState)\n\t\t);\n\t}\n\n\toldProps = c.props;\n\toldState = c.state;\n\tif (isNew) {\n\t\tif (type.getDerivedStateFromProps == null && c.componentWillMount != null) {\n\t\t\tc.componentWillMount();\n\t\t}\n\n\t\tif (c.componentDidMount != null) {\n\t\t\t// If the component was constructed, queue up componentDidMount so the\n\t\t\t// first time this internal commits (regardless of suspense or not) it\n\t\t\t// will be called\n\t\t\taddCommitCallback(internal, c.componentDidMount.bind(c));\n\t\t}\n\t} else {\n\t\tif (\n\t\t\ttype.getDerivedStateFromProps == null &&\n\t\t\tnewProps !== oldProps &&\n\t\t\tc.componentWillReceiveProps != null\n\t\t) {\n\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t}\n\n\t\tif (\n\t\t\t(!(internal.flags & FORCE_UPDATE) &&\n\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\tc.shouldComponentUpdate(newProps, c._nextState, componentContext) ===\n\t\t\t\t\tfalse) ||\n\t\t\t(newVNode && newVNode._vnodeId === internal._vnodeId)\n\t\t) {\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\t\t\tinternal.flags |= SKIP_CHILDREN;\n\t\t\treturn;\n\t\t}\n\n\t\tif (c.componentWillUpdate != null) {\n\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t}\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\tc.state = c._nextState;\n\n\tif ((tmp = options._render)) tmp(internal);\n\n\tinternal.flags &= ~DIRTY_BIT;\n\tc._internal = internal;\n\n\ttmp = c.render(c.props, c.state, c.context);\n\n\t// Handle setState called in render, see #2553\n\tc.state = c._nextState;\n\n\tif (c.getChildContext != null) {\n\t\tinternal._context = Object.assign({}, context, c.getChildContext());\n\t}\n\n\tif (!isNew) {\n\t\tif (c.getSnapshotBeforeUpdate != null) {\n\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t}\n\n\t\t// Only schedule componentDidUpdate if the component successfully rendered\n\t\tif (c.componentDidUpdate != null) {\n\t\t\taddCommitCallback(internal, () => {\n\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t});\n\t\t}\n\t}\n\n\treturn tmp;\n}\n","import { enqueueRender } from './component';\n\nlet nextContextId = 0;\n\nconst providers = new Set();\n\nexport const unsubscribeFromContext = internal => {\n\t// if this was a context provider, delete() returns true and we exit:\n\tif (providers.delete(internal)) return;\n\t// ... otherwise, unsubscribe from any contexts:\n\tproviders.forEach(p => {\n\t\tp._component._subs.delete(internal);\n\t});\n};\n\nexport const createContext = (defaultValue, contextId) => {\n\tcontextId = '__cC' + nextContextId++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props, ctx) {\n\t\t\t// initial setup:\n\t\t\tif (!this._subs) {\n\t\t\t\tthis._subs = new Set();\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\t\t\t\tthis.getChildContext = () => ctx;\n\t\t\t\tproviders.add(this._internal);\n\t\t\t}\n\t\t\t// re-render subscribers in response to value change\n\t\t\telse if (props.value !== this._prev) {\n\t\t\t\tthis._subs.forEach(enqueueRender);\n\t\t\t}\n\t\t\tthis._prev = props.value;\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n};\n","import { MODE_UNMOUNTING, TYPE_DOM, TYPE_ROOT } from '../constants';\nimport { unsubscribeFromContext } from '../create-context';\nimport options from '../options';\nimport { applyRef } from './refs';\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').Internal} internal The virtual node to unmount\n * @param {import('../internal').Internal} parentInternal The parent of the VNode that\n * initiated the unmount\n * @param {number} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(internal, parentInternal, skipRemove) {\n\tlet r,\n\t\ti = 0;\n\tif (options.unmount) options.unmount(internal);\n\tinternal.flags |= MODE_UNMOUNTING;\n\n\tif ((r = internal.ref)) {\n\t\tif (!r.current || r.current === internal._dom)\n\t\t\tapplyRef(null, r, null, parentInternal);\n\t}\n\n\tif ((r = internal._component)) {\n\t\tunsubscribeFromContext(internal);\n\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentInternal);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((r = internal._children)) {\n\t\tfor (; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentInternal,\n\t\t\t\t\tskipRemove ? ~internal.flags & TYPE_ROOT : internal.flags & TYPE_DOM\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && internal.flags & TYPE_DOM) {\n\t\tinternal._dom.remove();\n\t}\n\n\tinternal._dom = null;\n}\n","import { applyRef } from './refs';\nimport { normalizeToVNode } from '../create-element';\nimport {\n\tTYPE_COMPONENT,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tEMPTY_ARR,\n\tTYPE_DOM,\n\tUNDEFINED\n} from '../constants';\nimport { mount } from './mount';\nimport { patch } from './patch';\nimport { unmount } from './unmount';\nimport { createInternal, getDomSibling } from '../tree';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').Internal} parentInternal The Internal node\n * whose children should be diff'ed against newParentVNode\n * @param {import('../internal').CommitQueue} commitQueue List of\n * components which have callbacks to invoke in commitRoot\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tparentInternal,\n\tcommitQueue\n) {\n\tlet oldChildren =\n\t\t(parentInternal._children && parentInternal._children.slice()) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\tlet remainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\tlet i, newDom, refs;\n\n\t/** @type {import('../internal').Internal} */\n\tlet childInternal;\n\n\t/** @type {import('../internal').VNode | string} */\n\tlet childVNode;\n\n\tconst newChildren = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = normalizeToVNode(renderResult[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tnewChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet oldVNodeRef;\n\n\t\tlet skewedIndex = i + skew;\n\n\t\t/// TODO: Reconsider if we should bring back the \"not moving text nodes\" logic?\n\t\tlet matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\tif (matchingIndex === -1) {\n\t\t\tchildInternal = UNDEFINED;\n\t\t} else {\n\t\t\tchildInternal = oldChildren[matchingIndex];\n\t\t\toldChildren[matchingIndex] = UNDEFINED;\n\t\t\tremainingOldChildren--;\n\t\t}\n\n\t\tlet mountingChild = childInternal == null;\n\n\t\tif (mountingChild) {\n\t\t\tchildInternal = createInternal(childVNode, parentInternal);\n\n\t\t\t// We are mounting a new VNode\n\t\t\tmount(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tgetDomSibling(parentInternal, skewedIndex)\n\t\t\t);\n\t\t}\n\t\t// If this node suspended during hydration, and no other flags are set:\n\t\t// @TODO: might be better to explicitly check for MODE_ERRORED here.\n\t\telse if (\n\t\t\t(childInternal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t) {\n\t\t\t// We are resuming the hydration of a VNode\n\t\t\toldVNodeRef = childInternal.ref;\n\n\t\t\tmount(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tchildInternal._dom\n\t\t\t);\n\t\t} else {\n\t\t\toldVNodeRef = childInternal.ref;\n\n\t\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\t\tpatch(parentDom, childVNode, childInternal, commitQueue);\n\t\t}\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childVNode.ref || oldVNodeRef) {\n\t\t\tif (!refs) refs = [];\n\t\t\tchildInternal.ref = childVNode.ref;\n\t\t\trefs.push(\n\t\t\t\toldVNodeRef,\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildInternal.flags & TYPE_COMPONENT\n\t\t\t\t\t? childInternal._component || newDom\n\t\t\t\t\t: newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\n\t\tgo: if (mountingChild) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// Perform insert of new dom\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\tlet nextSibling = getDomSibling(parentInternal, skewedIndex);\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\t// Move this DOM into its correct place\n\t\t\tif (matchingIndex === skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t\tbreak go;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\tif (remainingOldChildren > renderResult.length - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t\tbreak go;\n\t\t\t\t} else {\n\t\t\t\t\t// ### Change from keyed: I think this was missing from the algo...\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\tskew = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskew = 0;\n\t\t\t}\n\n\t\t\tskewedIndex = i + skew;\n\n\t\t\tif (matchingIndex == i) break go;\n\n\t\t\tlet nextSibling = getDomSibling(parentInternal, skewedIndex + 1);\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t} else {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t}\n\t\t}\n\n\t\tnewChildren[i] = childInternal;\n\t}\n\n\tparentInternal._children = newChildren;\n\n\t// Remove remaining oldChildren if there are any.\n\tif (remainingOldChildren > 0) {\n\t\tfor (i = oldChildrenLength; i--; ) {\n\t\t\tif (oldChildren[i] != null) {\n\t\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('../internal').VNode | string} childVNode\n * @param {import('../internal').Internal[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst type = typeof childVNode === 'string' ? null : childVNode.type;\n\tconst key = type !== null ? childVNode.key : UNDEFINED;\n\tlet match = -1;\n\tlet x = skewedIndex - 1; // i - 1;\n\tlet y = skewedIndex + 1; // i + 1;\n\tlet oldChild = oldChildren[skewedIndex]; // i\n\n\tif (\n\t\t// ### Change from keyed: support for matching null placeholders\n\t\toldChild === null ||\n\t\t(oldChild != null && oldChild.type === type && oldChild.key == key)\n\t) {\n\t\tmatch = skewedIndex; // i\n\t}\n\t// If there are any unused children left (ignoring an available in-place child which we just checked)\n\telse if (remainingOldChildren > (oldChild != null ? 1 : 0)) {\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldChild = oldChildren[x];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldChild = oldChildren[y];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t} else if (x < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactNode} nextSibling\n * @param {import('../internal').PreactNode} parentDom\n */\nexport function insertComponentDom(internal, nextSibling, parentDom) {\n\tif (internal._children == null) {\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < internal._children.length; i++) {\n\t\tlet childInternal = internal._children[i];\n\t\tif (childInternal) {\n\t\t\tchildInternal._parent = internal;\n\n\t\t\tif (childInternal.flags & TYPE_COMPONENT) {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t} else if (childInternal._dom != nextSibling) {\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tfor (children of children) {\n\t\t\ttoChildArray(children, out);\n\t\t}\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n","import { diffChildren, insertComponentDom } from './children';\nimport { setProperty } from './props';\nimport options from '../options';\nimport { renderClassComponent, renderFunctionComponent } from './component';\nimport {\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_ELEMENT,\n\tMODE_SUSPENDED,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tTYPE_CLASS,\n\tMODE_SVG,\n\tUNDEFINED,\n\tMODE_HYDRATE,\n\tMODE_PENDING_ERROR,\n\tMODE_RERENDERING_ERROR,\n\tSKIP_CHILDREN,\n\tDIRTY_BIT\n} from '../constants';\nimport { getDomSibling, getParentContext } from '../tree';\nimport { mountChildren } from './mount';\nimport { Fragment } from '../create-element';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n */\nexport function patch(parentDom, newVNode, internal, commitQueue) {\n\tlet dom = internal._dom;\n\tlet flags = internal.flags;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (newVNode !== internal.props) {\n\t\t\tdom.data = newVNode;\n\t\t\tinternal.props = newVNode;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== UNDEFINED) return null;\n\n\tif (options._diff) options._diff(internal, newVNode);\n\n\tif (flags & TYPE_ELEMENT) {\n\t\tif (newVNode._vnodeId !== internal._vnodeId) {\n\t\t\t// @ts-ignore dom is a PreactElement here\n\t\t\tpatchDOMElement(dom, newVNode, internal, commitQueue);\n\t\t\t// Once we have successfully rendered the new VNode, copy it's ID over\n\t\t\tinternal._vnodeId = newVNode._vnodeId;\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal.flags &= RESET_MODE;\n\t}\n\n\t/** @type {import('../index').ComponentChild} */\n\tlet nextDomSibling;\n\n\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t// top.\n\tlet prevParentDom = parentDom;\n\tif (flags & TYPE_ROOT) {\n\t\tparentDom = newVNode.props._parentDom;\n\n\t\tif (internal.props._parentDom !== newVNode.props._parentDom) {\n\t\t\tlet nextSibling =\n\t\t\t\tparentDom == prevParentDom ? getDomSibling(internal) : null;\n\t\t\tinsertComponentDom(internal, nextSibling, parentDom);\n\t\t}\n\t}\n\n\ttry {\n\t\tif (internal.flags & MODE_PENDING_ERROR) {\n\t\t\t// Toggle the MODE_PENDING_ERROR and MODE_RERENDERING_ERROR flags. In\n\t\t\t// actuality, this should turn off the MODE_PENDING_ERROR flag and turn on\n\t\t\t// the MODE_RERENDERING_ERROR flag.\n\t\t\tinternal.flags ^= MODE_PENDING_ERROR | MODE_RERENDERING_ERROR;\n\t\t}\n\n\t\tconst context = getParentContext(internal);\n\n\t\t// Necessary for createContext api. Setting this property will pass\n\t\t// the context value as `this.context` just for this component.\n\t\tlet tmp = newVNode.type.contextType;\n\t\tlet provider = tmp && context[tmp._id];\n\t\tlet componentContext = tmp\n\t\t\t? provider\n\t\t\t\t? provider.props.value\n\t\t\t\t: tmp._defaultValue\n\t\t\t: context;\n\t\tlet isNew = !internal || !internal._component;\n\n\t\tif (internal.flags & TYPE_CLASS) {\n\t\t\tnextDomSibling = renderClassComponent(\n\t\t\t\tnewVNode,\n\t\t\t\tinternal,\n\t\t\t\tcontext,\n\t\t\t\tcomponentContext\n\t\t\t);\n\t\t} else {\n\t\t\tnextDomSibling = renderFunctionComponent(\n\t\t\t\tnewVNode,\n\t\t\t\tinternal,\n\t\t\t\tcontext,\n\t\t\t\tcomponentContext\n\t\t\t);\n\t\t}\n\n\t\tif (internal.flags & SKIP_CHILDREN) {\n\t\t\tinternal.props = newVNode.props;\n\t\t\tinternal.flags &= ~SKIP_CHILDREN;\n\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\tif (newVNode && newVNode._vnodeId !== internal._vnodeId) {\n\t\t\t\tinternal.flags &= ~DIRTY_BIT;\n\t\t\t}\n\t\t} else {\n\t\t\tlet isTopLevelFragment =\n\t\t\t\tnextDomSibling != null &&\n\t\t\t\tnextDomSibling.type === Fragment &&\n\t\t\t\tnextDomSibling.key == null;\n\t\t\tlet renderResult = isTopLevelFragment\n\t\t\t\t? nextDomSibling.props.children\n\t\t\t\t: nextDomSibling;\n\n\t\t\tif (internal._children == null) {\n\t\t\t\tmountChildren(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\t\tinternal,\n\t\t\t\t\tcommitQueue,\n\t\t\t\t\t(internal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t\t\t\t\t? internal._dom\n\t\t\t\t\t\t: isNew || internal.flags & MODE_HYDRATE\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: getDomSibling(internal)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdiffChildren(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\t\tinternal,\n\t\t\t\t\tcommitQueue\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (internal._commitCallbacks != null && internal._commitCallbacks.length) {\n\t\t\tcommitQueue.push(internal);\n\t\t}\n\t} catch (e) {\n\t\t// @TODO: assign a new VNode ID here? Or NaN?\n\t\t// newVNode._vnodeId = 0;\n\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\t\toptions._catchError(e, internal);\n\t}\n\n\tif (options.diffed) options.diffed(internal);\n\n\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\tinternal.flags &= RESET_MODE;\n\t// Once we have successfully rendered the new VNode, copy it's ID over\n\tinternal._vnodeId = newVNode._vnodeId;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n */\nfunction patchDOMElement(dom, newVNode, internal, commitQueue) {\n\tlet oldProps = internal.props,\n\t\tnewProps = (internal.props = newVNode.props),\n\t\tisSvg = internal.flags & MODE_SVG,\n\t\ti,\n\t\tvalue,\n\t\ttmp,\n\t\tnewHtml,\n\t\toldHtml,\n\t\tnewChildren;\n\n\tfor (i in oldProps) {\n\t\tvalue = oldProps[i];\n\t\tif (i === 'key') {\n\t\t} else if (i === 'children') {\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\toldHtml = value;\n\t\t} else if (!(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, value, isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tvalue = newProps[i];\n\t\tif (i === 'key') {\n\t\t} else if (i === 'children') {\n\t\t\tnewChildren = value;\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\tnewHtml = value;\n\t\t} else if (\n\t\t\tvalue !== (tmp = oldProps[i]) ||\n\t\t\t((i === 'checked' || i === 'value') && value != null && value !== dom[i])\n\t\t) {\n\t\t\tsetProperty(dom, i, value, tmp, isSvg);\n\t\t}\n\t}\n\n\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\tif (newHtml) {\n\t\tvalue = newHtml.__html;\n\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\tif (!oldHtml || (value !== oldHtml.__html && value !== dom.innerHTML)) {\n\t\t\tdom.innerHTML = value;\n\t\t}\n\t\tinternal._children = null;\n\t} else {\n\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\tdiffChildren(\n\t\t\tdom,\n\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\tinternal,\n\t\t\tcommitQueue,\n\t\t\tdom.firstChild\n\t\t);\n\t}\n\n\tif (newProps.value != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.value;\n\t} else if (newProps.checked != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.checked;\n\t}\n}\n","import { addCommitCallback, commitRoot } from './diff/commit';\nimport options from './options';\nimport { createVNode, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport { DIRTY_BIT, FORCE_UPDATE, MODE_UNMOUNTING } from './constants';\nimport { getParentDom } from './tree';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._internal) {\n\t\tif (callback) addCommitCallback(this._internal, callback.bind(this));\n\t\tthis._internal.rerender(this._internal);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._internal.flags |= FORCE_UPDATE;\n\t\tif (callback) addCommitCallback(this._internal, callback.bind(this));\n\t\tthis._internal.rerender(this._internal);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nfunction rerender(internal) {\n\tif (~internal.flags & MODE_UNMOUNTING && internal.flags & DIRTY_BIT) {\n\t\tlet parentDom = getParentDom(internal);\n\n\t\tconst vnode = createVNode(\n\t\t\tinternal.type,\n\t\t\tinternal.props,\n\t\t\tinternal.key, // @TODO we shouldn't need to actually pass these\n\t\t\tinternal.ref, // since the mode flag should bypass key/ref handling\n\t\t\t0\n\t\t);\n\n\t\tconst commitQueue = [];\n\t\tpatch(parentDom, vnode, internal, commitQueue);\n\t\tcommitRoot(commitQueue, internal);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Internal>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of an internal\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nexport function enqueueRender(internal) {\n\tif (\n\t\t(!(internal.flags & DIRTY_BIT) &&\n\t\t\t(internal.flags |= DIRTY_BIT) &&\n\t\t\trerenderQueue.push(internal) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\twhile ((len = process._rerenderCount = rerenderQueue.length)) {\n\t\trerenderQueue.sort((a, b) => a._depth - b._depth);\n\t\twhile (len--) {\n\t\t\trerender(rerenderQueue.shift());\n\t\t}\n\t}\n}\nlet len = (process._rerenderCount = 0);\n","import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { enqueueRender } from './component';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal.flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals use NaN as an ID so that two are never equal.\n\tlet vnodeId = NaN;\n\n\tif (typeof vnode === 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t} else if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props || {};\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type === 'function'\n\t\t\t\t? type.prototype && 'render' in type.prototype\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal.flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tdata: typeof type == 'function' ? {} : null,\n\t\trerender: enqueueRender,\n\t\tflags,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_dom: null,\n\t\t_component: null,\n\t\t_context: null,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal.flags & TYPE_COMPONENT &&\n\t(!(internal.flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} [i]\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, i) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (i = i || 0; i < internal._children.length; i++) {\n\t\tlet child = internal._children[i];\n\t\tif (child != null) {\n\t\t\tif (child.flags & TYPE_DOM) {\n\t\t\t\treturn child._dom;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n/**\n * @param {import('./internal').Internal} internal\n * @returns {any}\n */\nexport function getParentContext(internal) {\n\tlet context = internal._context;\n\tlet parent = internal._parent;\n\twhile (context == null && parent) {\n\t\tcontext = parent._context;\n\t\tparent = parent._parent;\n\t}\n\n\treturn context;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parentDom = internal.flags & TYPE_ROOT ? internal.props._parentDom : null;\n\n\tlet parent = internal._parent;\n\twhile (parentDom == null && parent) {\n\t\tif (parent.flags & TYPE_ROOT) {\n\t\t\tparentDom = parent.props._parentDom;\n\t\t} else if (parent.flags & TYPE_ELEMENT) {\n\t\t\tparentDom = parent._dom;\n\t\t}\n\n\t\tparent = parent._parent;\n\t}\n\n\treturn parentDom;\n}\n","import { applyRef } from './refs';\nimport {\n\tTYPE_COMPONENT,\n\tTYPE_ELEMENT,\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tMODE_SVG\n} from '../constants';\nimport { normalizeToVNode, Fragment } from '../create-element';\nimport { setProperty } from './props';\nimport { renderClassComponent, renderFunctionComponent } from './component';\nimport { createInternal, getParentContext } from '../tree';\nimport options from '../options';\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom\n * @returns {import('../internal').PreactElement | null} pointer to the next DOM node to be hydrated (or null)\n */\nexport function mount(parentDom, newVNode, internal, commitQueue, startDom) {\n\tif (options._diff) options._diff(internal, newVNode);\n\n\t/** @type {import('../index').ComponentChild} */\n\tlet nextDomSibling;\n\n\ttry {\n\t\tif (internal.flags & TYPE_COMPONENT) {\n\t\t\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t\t\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t\t\t// top.\n\t\t\tlet prevStartDom = startDom;\n\t\t\tlet prevParentDom = parentDom;\n\t\t\tif (internal.flags & TYPE_ROOT) {\n\t\t\t\tparentDom = newVNode.props._parentDom;\n\n\t\t\t\tif (parentDom !== prevParentDom) {\n\t\t\t\t\tstartDom = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst context = getParentContext(internal);\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\tlet tmp = newVNode.type.contextType;\n\t\t\tlet provider = tmp && context[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: context;\n\n\t\t\tif (provider) provider._subs.add(internal);\n\n\t\t\tif (internal.flags & TYPE_CLASS) {\n\t\t\t\tnextDomSibling = renderClassComponent(\n\t\t\t\t\tnull,\n\t\t\t\t\tinternal,\n\t\t\t\t\tcontext,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tnextDomSibling = renderFunctionComponent(\n\t\t\t\t\tnull,\n\t\t\t\t\tinternal,\n\t\t\t\t\tcontext,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\tnextDomSibling != null &&\n\t\t\t\tnextDomSibling.type === Fragment &&\n\t\t\t\tnextDomSibling.key == null;\n\n\t\t\tlet renderResult = isTopLevelFragment\n\t\t\t\t? nextDomSibling.props.children\n\t\t\t\t: nextDomSibling;\n\n\t\t\tnextDomSibling = mountChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tinternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tstartDom\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tinternal._commitCallbacks != null &&\n\t\t\t\tinternal._commitCallbacks.length\n\t\t\t) {\n\t\t\t\tcommitQueue.push(internal);\n\t\t\t}\n\n\t\t\tif (internal.flags & TYPE_ROOT && prevParentDom !== parentDom) {\n\t\t\t\t// If we just mounted a root node/Portal, and it changed the parentDom\n\t\t\t\t// of it's children, then we need to resume the diff from it's previous\n\t\t\t\t// startDom element, which could be null if we are mounting an entirely\n\t\t\t\t// new tree, or the portal's nextSibling if we are mounting a Portal in\n\t\t\t\t// an existing tree.\n\t\t\t\tnextDomSibling = prevStartDom;\n\t\t\t}\n\t\t} else {\n\t\t\tlet hydrateDom =\n\t\t\t\tinternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)\n\t\t\t\t\t? startDom\n\t\t\t\t\t: null;\n\n\t\t\tnextDomSibling = mountDOMElement(hydrateDom, internal, commitQueue);\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal.flags &= RESET_MODE;\n\t} catch (e) {\n\t\tinternal._vnodeId = 0;\n\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\n\t\tif (internal.flags & MODE_HYDRATE) {\n\t\t\t// @ts-ignore Trust me TS, nextSibling is a PreactElement\n\t\t\tnextDomSibling = startDom && startDom.nextSibling;\n\t\t\tinternal._dom = startDom; // Save our current DOM position to resume later\n\t\t}\n\t\toptions._catchError(e, internal);\n\t}\n\n\treturn nextDomSibling;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @returns {import('../internal').PreactElement}\n */\nfunction mountDOMElement(dom, internal, commitQueue) {\n\tlet newProps = internal.props;\n\tlet nodeType = internal.type;\n\t/** @type {any} */\n\tlet i, value;\n\n\tlet flags = internal.flags;\n\tlet isSvg = flags & MODE_SVG;\n\n\t// Are we *not* hydrating? (a top-level render() or mutative hydration):\n\tlet isFullRender = ~flags & MODE_HYDRATE;\n\n\t// if hydrating (hydrate() or render() with replaceNode), find the matching child:\n\tif (flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)) {\n\t\twhile (\n\t\t\tdom &&\n\t\t\t(nodeType ? dom.localName !== nodeType : dom.nodeType !== 3)\n\t\t) {\n\t\t\tdom = dom.nextSibling;\n\t\t}\n\t}\n\n\tlet isNew = dom == null;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (isNew) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\tdom = document.createTextNode(newProps);\n\t\t} else if (dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\n\t\tinternal._dom = dom;\n\t} else {\n\t\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\t\t// if (nodeType === 'svg') internal.flags |= MODE_SVG;\n\n\t\tif (isNew) {\n\t\t\tif (isSvg) {\n\t\t\t\tdom = document.createElementNS(\n\t\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType,\n\t\t\t\t\tnewProps.is && newProps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\t\tinternal.flags = flags &= RESET_MODE;\n\t\t\tisFullRender = 1;\n\t\t}\n\n\t\t// @TODO: Consider removing and instructing users to instead set the desired\n\t\t// prop for removal to undefined/null. During hydration, props are not\n\t\t// diffed at all (including dangerouslySetInnerHTML)\n\t\tif (flags & MODE_MUTATIVE_HYDRATE) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i].name;\n\t\t\t\tif (!(value in newProps)) {\n\t\t\t\t\tdom.removeAttribute(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet newHtml, newValue, newChildren;\n\t\tif (\n\t\t\t(internal.type === 'input' ||\n\t\t\t\tinternal.type === 'textarea' ||\n\t\t\t\tinternal.type === 'select') &&\n\t\t\t(newProps.onInput || newProps.onChange)\n\t\t) {\n\t\t\tif (newProps.value != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.value;\n\t\t\t} else if (newProps.checked != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.checked;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i === 'key') {\n\t\t\t} else if (i === 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i === 'value') {\n\t\t\t\tnewValue = value;\n\t\t\t} else if (\n\t\t\t\tvalue != null &&\n\t\t\t\t(isFullRender || typeof value === 'function')\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, null, isSvg);\n\t\t\t}\n\t\t}\n\n\t\tinternal._dom = dom;\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tif (isFullRender && newHtml.__html) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\t\t\tinternal._children = null;\n\t\t} else if (newChildren != null) {\n\t\t\tmountChildren(\n\t\t\t\tdom,\n\t\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tinternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tisNew ? null : dom.firstChild\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (isFullRender && newValue != null) {\n\t\t\tsetProperty(dom, 'value', newValue, null, 0);\n\t\t}\n\t}\n\n\t// @ts-ignore\n\treturn isNew ? null : dom.nextSibling;\n}\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').Internal} parentInternal The parent Internal of the given children\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom\n */\nexport function mountChildren(\n\tparentDom,\n\trenderResult,\n\tparentInternal,\n\tcommitQueue,\n\tstartDom\n) {\n\tlet internalChildren = (parentInternal._children = []),\n\t\ti,\n\t\tchildVNode,\n\t\tchildInternal,\n\t\tnewDom,\n\t\tmountedNextChild;\n\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = normalizeToVNode(renderResult[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tinternalChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildInternal = createInternal(childVNode, parentInternal);\n\t\tinternalChildren[i] = childInternal;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tmountedNextChild = mount(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\tchildInternal,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childInternal.flags & TYPE_COMPONENT || newDom == startDom) {\n\t\t\t// If the child is a Fragment-like or if it is DOM VNode and its _dom\n\t\t\t// property matches the dom we are diffing (i.e. startDom), just\n\t\t\t// continue with the mountedNextChild\n\t\t\tstartDom = mountedNextChild;\n\t\t} else if (newDom != null) {\n\t\t\t// The DOM the diff should begin with is now startDom (since we inserted\n\t\t\t// newDom before startDom) so ignore mountedNextChild and continue with\n\t\t\t// startDom\n\t\t\tparentDom.insertBefore(newDom, startDom);\n\t\t}\n\n\t\tif (childInternal.ref) {\n\t\t\tapplyRef(\n\t\t\t\tnull,\n\t\t\t\tchildInternal.ref,\n\t\t\t\tchildInternal._component || newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode.\n\tif (\n\t\tparentInternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE) &&\n\t\tparentInternal.flags & TYPE_ELEMENT\n\t) {\n\t\t// TODO: Would it be simpler to just clear the pre-existing DOM in top-level\n\t\t// render if render is called with no oldVNode & existing children & no\n\t\t// replaceNode? Instead of patching the DOM to match the VNode tree? (remove\n\t\t// attributes & unused DOM)\n\t\twhile (startDom) {\n\t\t\ti = startDom;\n\t\t\tstartDom = startDom.nextSibling;\n\t\t\ti.remove();\n\t\t}\n\t}\n\n\treturn startDom;\n}\n","import {\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { commitRoot } from './diff/commit';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { mount } from './diff/mount';\nimport { patch } from './diff/patch';\nimport { createInternal } from './tree';\n\n/**\n *\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * @returns {import('./internal').Root}\n */\nexport function createRoot(parentDom) {\n\tlet rootInternal,\n\t\tcommitQueue,\n\t\tfirstChild,\n\t\tflags = 0;\n\n\tfunction render(vnode) {\n\t\tif (options._root) options._root(vnode, parentDom);\n\n\t\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\n\t\tfirstChild =\n\t\t\t/** @type {import('./internal').PreactElement} */ (parentDom.firstChild);\n\n\t\t// List of effects that need to be called after diffing:\n\t\tcommitQueue = [];\n\n\t\tif (rootInternal) {\n\t\t\tpatch(parentDom, vnode, rootInternal, commitQueue);\n\t\t} else {\n\t\t\trootInternal = createInternal(vnode);\n\n\t\t\t// Store the VDOM tree root on the DOM element in a (minified) property:\n\t\t\tparentDom._children = rootInternal;\n\n\t\t\t// Calling createRoot().render() on an Element with existing children triggers mutative hydrate mode:\n\t\t\tif (firstChild) {\n\t\t\t\tflags = flags || MODE_MUTATIVE_HYDRATE;\n\t\t\t}\n\t\t\t// If the parent of this tree is within an inline SVG, the tree should start off in SVG mode:\n\t\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\t\tflags |= MODE_SVG;\n\t\t\t}\n\t\t\trootInternal.flags |= flags;\n\n\t\t\trootInternal._context = {};\n\n\t\t\tmount(parentDom, vnode, rootInternal, commitQueue, firstChild);\n\t\t}\n\n\t\t// Flush all queued effects\n\t\tcommitRoot(commitQueue, rootInternal);\n\t}\n\n\treturn {\n\t\thydrate(vnode) {\n\t\t\tflags |= MODE_HYDRATE;\n\t\t\trender(vnode);\n\t\t},\n\t\trender\n\t};\n}\n","import { createRoot } from './create-root';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.render(vnode);\n\tparentDom._root = root;\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.hydrate(vnode);\n\tparentDom._root = root;\n}\n","import { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = Object.assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\t0\n\t);\n}\n","import { createElement } from './create-element';\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\treturn props.children;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\t// Note: We can't use Fragment here because a component that returned a Portal\n\t// (e.g. `const App = () => createPortal(...)`) wouldn't work. Our diff\n\t// collapses Fragments without keys that are returned directly from components\n\t// into just an array and sets that as the children array of the component.\n\t//\n\t// We also can't use keyed Fragments here cuz it might lead to weird edge\n\t// cases when toggling between two sibling portals if we use a shared keyed or\n\t// lead to unnecessary re-mounts if trying to generate a new key on each call.\n\t//\n\t// So the simplest solution seems to be just to use an unique type for Portal\n\t// to skip the Fragment collapsing logic when diffing components\n\treturn createElement(Portal, { _parentDom: container }, vnode);\n}\n"],"names":["EMPTY_ARR","options","[object Object]","error","internal","TYPE_CLASS","flags","type","getDerivedStateFromError","setState","componentDidCatch","e","addCommitCallback","callback","push","commitRoot","commitQueue","rootInternal","some","length","shift","vnodeId","createElement","props","children","key","ref","i","normalizedProps","arguments","createVNode","original","vnode","constructor","undefined","__v","normalizeToVNode","childVNode","Array","isArray","Fragment","createRef","current","isValidElement","applyRef","oldRef","value","setStyle","dom","style","setProperty","name","oldValue","isSvg","useCapture","o","replace","toLowerCase","slice","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","setAttribute","removeAttribute","this","event","_isControlled","_prevValue","checked","renderFunctionComponent","newVNode","context","componentContext","c","tmp","newProps","forceUpdate","rerender","bind","call","getChildContext","Object","assign","renderClassComponent","isNew","oldProps","oldState","snapshot","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","render","getSnapshotBeforeUpdate","componentDidUpdate","nextContextId","providers","Set","unsubscribeFromContext","delete","forEach","p","createContext","defaultValue","contextId","__c","__","Consumer","contextValue","Provider","ctx","enqueueRender","add","contextType","unmount","parentInternal","skipRemove","r","componentWillUnmount","TYPE_TEXT","remove","diffChildren","parentDom","renderResult","newDom","refs","childInternal","oldChildren","oldChildrenLength","remainingOldChildren","skew","newChildren","oldVNodeRef","skewedIndex","matchingIndex","findMatchingIndex","mountingChild","createInternal","mount","getDomSibling","patch","go","nextSibling","insertBefore","insertComponentDom","match","x","y","oldChild","toChildArray","out","nextDomSibling","data","patchDOMElement","diffed","prevParentDom","MODE_PENDING_ERROR","getParentContext","provider","mountChildren","then","newHtml","oldHtml","innerHTML","Component","getParentDom","prototype","update","s","prevDebounce","rerenderQueue","defer","Promise","resolve","process","debounceRendering","len","sort","a","b","MODE_HYDRATE","NaN","__k","__e","__b","shouldSearchComponent","childIndex","indexOf","getChildDom","child","childDom","parent","startDom","prevStartDom","mountDOMElement","nodeType","isFullRender","localName","document","createTextNode","createElementNS","is","attributes","newValue","onInput","onChange","firstChild","mountedNextChild","internalChildren","createRoot","__P","ownerSVGElement","hydrate","root","cloneElement","Portal","createPortal","container"],"mappings":"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"}