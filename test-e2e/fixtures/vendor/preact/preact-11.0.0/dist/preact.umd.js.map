{"version":3,"file":"preact.umd.js","sources":["../src/options.js","../src/create-element.js","../src/create-context.js","../src/component.js","../src/tree.js","../src/constants.js","../src/diff/commit.js","../src/diff/refs.js","../src/diff/props.js","../src/diff/component.js","../src/diff/unmount.js","../src/diff/children.js","../src/diff/patch.js","../src/diff/mount.js","../src/create-root.js","../src/create-portal.js","../src/diff/catch-error.js","../src/clone-element.js","../src/render.js"],"sourcesContent":["import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { UNDEFINED } from './constants';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, 0);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tconstructor: undefined,\n\t\t_vnodeId: original || ++vnodeId\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\n/**\n * @param {import('./internal').ComponentChildren} childVNode\n * @returns {import('./internal').VNode | string | null}\n */\nexport function normalizeToVNode(childVNode) {\n\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\treturn null;\n\t}\n\n\tif (typeof childVNode === 'object') {\n\t\treturn Array.isArray(childVNode)\n\t\t\t? createVNode(Fragment, { children: childVNode }, null, null, 0)\n\t\t\t: childVNode;\n\t}\n\n\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t// it's own DOM & etc. pointers\n\treturn typeof childVNode === 'function' ? childVNode : childVNode + '';\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === UNDEFINED;\n","import { enqueueRender } from './component';\n\nlet nextContextId = 0;\n\nconst providers = new Set();\n\nexport const unsubscribeFromContext = internal => {\n\t// if this was a context provider, delete() returns true and we exit:\n\tif (providers.delete(internal)) return;\n\t// ... otherwise, unsubscribe from any contexts:\n\tproviders.forEach(p => {\n\t\tp._component._subs.delete(internal);\n\t});\n};\n\nexport const createContext = (defaultValue, contextId) => {\n\tcontextId = '__cC' + nextContextId++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props, ctx) {\n\t\t\t// initial setup:\n\t\t\tif (!this._subs) {\n\t\t\t\tthis._subs = new Set();\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\t\t\t\tthis.getChildContext = () => ctx;\n\t\t\t\tproviders.add(this._internal);\n\t\t\t}\n\t\t\t// re-render subscribers in response to value change\n\t\t\telse if (props.value !== this._prev) {\n\t\t\t\tthis._subs.forEach(enqueueRender);\n\t\t\t}\n\t\t\tthis._prev = props.value;\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n};\n","import { addCommitCallback, commitRoot } from './diff/commit';\nimport options from './options';\nimport { createVNode, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport { DIRTY_BIT, FORCE_UPDATE, MODE_UNMOUNTING } from './constants';\nimport { getParentDom } from './tree';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._internal) {\n\t\tif (callback) addCommitCallback(this._internal, callback.bind(this));\n\t\tthis._internal.rerender(this._internal);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._internal.flags |= FORCE_UPDATE;\n\t\tif (callback) addCommitCallback(this._internal, callback.bind(this));\n\t\tthis._internal.rerender(this._internal);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nfunction rerender(internal) {\n\tif (~internal.flags & MODE_UNMOUNTING && internal.flags & DIRTY_BIT) {\n\t\tlet parentDom = getParentDom(internal);\n\n\t\tconst vnode = createVNode(\n\t\t\tinternal.type,\n\t\t\tinternal.props,\n\t\t\tinternal.key, // @TODO we shouldn't need to actually pass these\n\t\t\tinternal.ref, // since the mode flag should bypass key/ref handling\n\t\t\t0\n\t\t);\n\n\t\tconst commitQueue = [];\n\t\tpatch(parentDom, vnode, internal, commitQueue);\n\t\tcommitRoot(commitQueue, internal);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Internal>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of an internal\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nexport function enqueueRender(internal) {\n\tif (\n\t\t(!(internal.flags & DIRTY_BIT) &&\n\t\t\t(internal.flags |= DIRTY_BIT) &&\n\t\t\trerenderQueue.push(internal) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\twhile ((len = process._rerenderCount = rerenderQueue.length)) {\n\t\trerenderQueue.sort((a, b) => a._depth - b._depth);\n\t\twhile (len--) {\n\t\t\trerender(rerenderQueue.shift());\n\t\t}\n\t}\n}\nlet len = (process._rerenderCount = 0);\n","import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { enqueueRender } from './component';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal.flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals use NaN as an ID so that two are never equal.\n\tlet vnodeId = NaN;\n\n\tif (typeof vnode === 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t} else if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props || {};\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type === 'function'\n\t\t\t\t? type.prototype && 'render' in type.prototype\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal.flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tdata: typeof type == 'function' ? {} : null,\n\t\trerender: enqueueRender,\n\t\tflags,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_dom: null,\n\t\t_component: null,\n\t\t_context: null,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal.flags & TYPE_COMPONENT &&\n\t(!(internal.flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} [i]\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, i) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (i = i || 0; i < internal._children.length; i++) {\n\t\tlet child = internal._children[i];\n\t\tif (child != null) {\n\t\t\tif (child.flags & TYPE_DOM) {\n\t\t\t\treturn child._dom;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n/**\n * @param {import('./internal').Internal} internal\n * @returns {any}\n */\nexport function getParentContext(internal) {\n\tlet context = internal._context;\n\tlet parent = internal._parent;\n\twhile (context == null && parent) {\n\t\tcontext = parent._context;\n\t\tparent = parent._parent;\n\t}\n\n\treturn context;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parentDom = internal.flags & TYPE_ROOT ? internal.props._parentDom : null;\n\n\tlet parent = internal._parent;\n\twhile (parentDom == null && parent) {\n\t\tif (parent.flags & TYPE_ROOT) {\n\t\t\tparentDom = parent.props._parentDom;\n\t\t} else if (parent.flags & TYPE_ELEMENT) {\n\t\t\tparentDom = parent._dom;\n\t\t}\n\n\t\tparent = parent._parent;\n\t}\n\n\treturn parentDom;\n}\n","// Internal.flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n/** Signals the component can skip children due to a non-update */\nexport const SKIP_CHILDREN = 1 << 15;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE |\n\tSKIP_CHILDREN\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n","import options from '../options';\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {() => void} callback\n */\nexport function addCommitCallback(internal, callback) {\n\tif (internal._commitCallbacks == null) {\n\t\tinternal._commitCallbacks = [];\n\t}\n\n\tinternal._commitCallbacks.push(callback);\n}\n\n/**\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').Internal} rootInternal\n */\nexport function commitRoot(commitQueue, rootInternal) {\n\tif (options._commit) options._commit(rootInternal, commitQueue);\n\n\tcommitQueue.some(internal => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the root variable here so the type changes\n\t\t\tcommitQueue = internal._commitCallbacks.length;\n\t\t\t// @ts-ignore See above ts-ignore comment\n\t\t\twhile (commitQueue--) {\n\t\t\t\tinternal._commitCallbacks.shift()();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n}\n","import options from '../options';\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').Internal} internal\n */\nexport function applyRef(oldRef, ref, value, internal) {\n\tif (oldRef === ref) return;\n\n\tif (oldRef) applyRef(null, oldRef, null, internal);\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse if (ref) ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, internal);\n\t}\n}\n","import options from '../options';\n\nfunction setStyle(dom, key, value) {\n\tif (key[0] === '-') {\n\t\tdom.style.setProperty(key, value);\n\t} else {\n\t\tdom.style[key] = value == null ? '' : value;\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {number} isSvg 0 if not an SVG element, else it is an SVG element\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tsetStyle(dom, 'cssText', value);\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tsetStyle(dom, 'cssText', (oldValue = ''));\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!value || !(name in value)) {\n\t\t\t\t\t\tsetStyle(dom, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (name in value) {\n\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\tsetStyle(dom, name, value[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n\tif (this._isControlled) {\n\t\tif (this.value != null && (e.type === 'input' || e.type === 'change')) {\n\t\t\tthis.value = this._prevValue;\n\t\t}\n\t\tif (this.checked != null && e.type === 'change') {\n\t\t\tthis.checked = this._prevValue;\n\t\t}\n\t}\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import options from '../options';\nimport { DIRTY_BIT, FORCE_UPDATE, SKIP_CHILDREN } from '../constants';\nimport { addCommitCallback } from './commit';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @returns {import('../index').ComponentChild} pointer to the next DOM node (in order) to be rendered (or null)\n */\nexport function renderFunctionComponent(\n\tnewVNode,\n\tinternal,\n\tcontext,\n\tcomponentContext\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet tmp;\n\n\t/** @type {import('../internal').ComponentType} */\n\tlet type = (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (internal && internal._component) {\n\t\tc = internal._component;\n\t} else {\n\t\tinternal._component = c = {\n\t\t\tprops: newProps,\n\t\t\tcontext: componentContext,\n\t\t\tforceUpdate: internal.rerender.bind(null, internal)\n\t\t};\n\n\t\tinternal.flags |= DIRTY_BIT;\n\t}\n\n\tif (newVNode && newVNode._vnodeId === internal._vnodeId) {\n\t\tc.props = newProps;\n\t\tinternal.flags |= SKIP_CHILDREN;\n\t\treturn;\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\n\tif ((tmp = options._render)) tmp(internal);\n\n\tinternal.flags &= ~DIRTY_BIT;\n\tc._internal = internal;\n\n\ttmp = type.call(c, c.props, c.context);\n\n\tif (c.getChildContext != null) {\n\t\tinternal._context = Object.assign({}, context, c.getChildContext());\n\t}\n\n\treturn tmp;\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @returns {import('../index').ComponentChild} pointer to the next DOM node (in order) to be rendered (or null)\n */\nexport function renderClassComponent(\n\tnewVNode,\n\tinternal,\n\tcontext,\n\tcomponentContext\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet isNew, oldProps, oldState, snapshot, tmp;\n\n\t/** @type {import('../internal').ComponentType} */\n\tlet type = (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (internal && internal._component) {\n\t\tc = internal._component;\n\t} else {\n\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\tinternal._component = c = new type(newProps, componentContext); // eslint-disable-line new-cap\n\n\t\tif (!c.state) c.state = {};\n\t\tisNew = true;\n\t\tinternal.flags |= DIRTY_BIT;\n\t}\n\n\t// Invoke getDerivedStateFromProps\n\tif (c._nextState == null) {\n\t\tc._nextState = c.state;\n\t}\n\tif (type.getDerivedStateFromProps != null) {\n\t\tif (c._nextState == c.state) {\n\t\t\tc._nextState = Object.assign({}, c._nextState);\n\t\t}\n\n\t\tObject.assign(\n\t\t\tc._nextState,\n\t\t\ttype.getDerivedStateFromProps(newProps, c._nextState)\n\t\t);\n\t}\n\n\toldProps = c.props;\n\toldState = c.state;\n\tif (isNew) {\n\t\tif (type.getDerivedStateFromProps == null && c.componentWillMount != null) {\n\t\t\tc.componentWillMount();\n\t\t}\n\n\t\tif (c.componentDidMount != null) {\n\t\t\t// If the component was constructed, queue up componentDidMount so the\n\t\t\t// first time this internal commits (regardless of suspense or not) it\n\t\t\t// will be called\n\t\t\taddCommitCallback(internal, c.componentDidMount.bind(c));\n\t\t}\n\t} else {\n\t\tif (\n\t\t\ttype.getDerivedStateFromProps == null &&\n\t\t\tnewProps !== oldProps &&\n\t\t\tc.componentWillReceiveProps != null\n\t\t) {\n\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t}\n\n\t\tif (\n\t\t\t(!(internal.flags & FORCE_UPDATE) &&\n\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\tc.shouldComponentUpdate(newProps, c._nextState, componentContext) ===\n\t\t\t\t\tfalse) ||\n\t\t\t(newVNode && newVNode._vnodeId === internal._vnodeId)\n\t\t) {\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\t\t\tinternal.flags |= SKIP_CHILDREN;\n\t\t\treturn;\n\t\t}\n\n\t\tif (c.componentWillUpdate != null) {\n\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t}\n\t}\n\n\tc.context = componentContext;\n\tinternal.props = c.props = newProps;\n\tc.state = c._nextState;\n\n\tif ((tmp = options._render)) tmp(internal);\n\n\tinternal.flags &= ~DIRTY_BIT;\n\tc._internal = internal;\n\n\ttmp = c.render(c.props, c.state, c.context);\n\n\t// Handle setState called in render, see #2553\n\tc.state = c._nextState;\n\n\tif (c.getChildContext != null) {\n\t\tinternal._context = Object.assign({}, context, c.getChildContext());\n\t}\n\n\tif (!isNew) {\n\t\tif (c.getSnapshotBeforeUpdate != null) {\n\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t}\n\n\t\t// Only schedule componentDidUpdate if the component successfully rendered\n\t\tif (c.componentDidUpdate != null) {\n\t\t\taddCommitCallback(internal, () => {\n\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t});\n\t\t}\n\t}\n\n\treturn tmp;\n}\n","import { MODE_UNMOUNTING, TYPE_DOM, TYPE_ROOT } from '../constants';\nimport { unsubscribeFromContext } from '../create-context';\nimport options from '../options';\nimport { applyRef } from './refs';\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').Internal} internal The virtual node to unmount\n * @param {import('../internal').Internal} parentInternal The parent of the VNode that\n * initiated the unmount\n * @param {number} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(internal, parentInternal, skipRemove) {\n\tlet r,\n\t\ti = 0;\n\tif (options.unmount) options.unmount(internal);\n\tinternal.flags |= MODE_UNMOUNTING;\n\n\tif ((r = internal.ref)) {\n\t\tif (!r.current || r.current === internal._dom)\n\t\t\tapplyRef(null, r, null, parentInternal);\n\t}\n\n\tif ((r = internal._component)) {\n\t\tunsubscribeFromContext(internal);\n\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentInternal);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((r = internal._children)) {\n\t\tfor (; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentInternal,\n\t\t\t\t\tskipRemove ? ~internal.flags & TYPE_ROOT : internal.flags & TYPE_DOM\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && internal.flags & TYPE_DOM) {\n\t\tinternal._dom.remove();\n\t}\n\n\tinternal._dom = null;\n}\n","import { applyRef } from './refs';\nimport { normalizeToVNode } from '../create-element';\nimport {\n\tTYPE_COMPONENT,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tEMPTY_ARR,\n\tTYPE_DOM,\n\tUNDEFINED\n} from '../constants';\nimport { mount } from './mount';\nimport { patch } from './patch';\nimport { unmount } from './unmount';\nimport { createInternal, getDomSibling } from '../tree';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').Internal} parentInternal The Internal node\n * whose children should be diff'ed against newParentVNode\n * @param {import('../internal').CommitQueue} commitQueue List of\n * components which have callbacks to invoke in commitRoot\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tparentInternal,\n\tcommitQueue\n) {\n\tlet oldChildren =\n\t\t(parentInternal._children && parentInternal._children.slice()) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\tlet remainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\tlet i, newDom, refs;\n\n\t/** @type {import('../internal').Internal} */\n\tlet childInternal;\n\n\t/** @type {import('../internal').VNode | string} */\n\tlet childVNode;\n\n\tconst newChildren = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = normalizeToVNode(renderResult[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tnewChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet oldVNodeRef;\n\n\t\tlet skewedIndex = i + skew;\n\n\t\t/// TODO: Reconsider if we should bring back the \"not moving text nodes\" logic?\n\t\tlet matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\tif (matchingIndex === -1) {\n\t\t\tchildInternal = UNDEFINED;\n\t\t} else {\n\t\t\tchildInternal = oldChildren[matchingIndex];\n\t\t\toldChildren[matchingIndex] = UNDEFINED;\n\t\t\tremainingOldChildren--;\n\t\t}\n\n\t\tlet mountingChild = childInternal == null;\n\n\t\tif (mountingChild) {\n\t\t\tchildInternal = createInternal(childVNode, parentInternal);\n\n\t\t\t// We are mounting a new VNode\n\t\t\tmount(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tgetDomSibling(parentInternal, skewedIndex)\n\t\t\t);\n\t\t}\n\t\t// If this node suspended during hydration, and no other flags are set:\n\t\t// @TODO: might be better to explicitly check for MODE_ERRORED here.\n\t\telse if (\n\t\t\t(childInternal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t) {\n\t\t\t// We are resuming the hydration of a VNode\n\t\t\toldVNodeRef = childInternal.ref;\n\n\t\t\tmount(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tchildInternal._dom\n\t\t\t);\n\t\t} else {\n\t\t\toldVNodeRef = childInternal.ref;\n\n\t\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\t\tpatch(parentDom, childVNode, childInternal, commitQueue);\n\t\t}\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childVNode.ref || oldVNodeRef) {\n\t\t\tif (!refs) refs = [];\n\t\t\tchildInternal.ref = childVNode.ref;\n\t\t\trefs.push(\n\t\t\t\toldVNodeRef,\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildInternal.flags & TYPE_COMPONENT\n\t\t\t\t\t? childInternal._component || newDom\n\t\t\t\t\t: newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\n\t\tgo: if (mountingChild) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// Perform insert of new dom\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\tlet nextSibling = getDomSibling(parentInternal, skewedIndex);\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\t// Move this DOM into its correct place\n\t\t\tif (matchingIndex === skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t\tbreak go;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\tif (remainingOldChildren > renderResult.length - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t\tbreak go;\n\t\t\t\t} else {\n\t\t\t\t\t// ### Change from keyed: I think this was missing from the algo...\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\tskew = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskew = 0;\n\t\t\t}\n\n\t\t\tskewedIndex = i + skew;\n\n\t\t\tif (matchingIndex == i) break go;\n\n\t\t\tlet nextSibling = getDomSibling(parentInternal, skewedIndex + 1);\n\t\t\tif (childInternal.flags & TYPE_DOM) {\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t} else {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t}\n\t\t}\n\n\t\tnewChildren[i] = childInternal;\n\t}\n\n\tparentInternal._children = newChildren;\n\n\t// Remove remaining oldChildren if there are any.\n\tif (remainingOldChildren > 0) {\n\t\tfor (i = oldChildrenLength; i--; ) {\n\t\t\tif (oldChildren[i] != null) {\n\t\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('../internal').VNode | string} childVNode\n * @param {import('../internal').Internal[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst type = typeof childVNode === 'string' ? null : childVNode.type;\n\tconst key = type !== null ? childVNode.key : UNDEFINED;\n\tlet match = -1;\n\tlet x = skewedIndex - 1; // i - 1;\n\tlet y = skewedIndex + 1; // i + 1;\n\tlet oldChild = oldChildren[skewedIndex]; // i\n\n\tif (\n\t\t// ### Change from keyed: support for matching null placeholders\n\t\toldChild === null ||\n\t\t(oldChild != null && oldChild.type === type && oldChild.key == key)\n\t) {\n\t\tmatch = skewedIndex; // i\n\t}\n\t// If there are any unused children left (ignoring an available in-place child which we just checked)\n\telse if (remainingOldChildren > (oldChild != null ? 1 : 0)) {\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldChild = oldChildren[x];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldChild = oldChildren[y];\n\t\t\t\tif (oldChild != null && oldChild.type === type && oldChild.key == key) {\n\t\t\t\t\tmatch = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t} else if (x < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactNode} nextSibling\n * @param {import('../internal').PreactNode} parentDom\n */\nexport function insertComponentDom(internal, nextSibling, parentDom) {\n\tif (internal._children == null) {\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < internal._children.length; i++) {\n\t\tlet childInternal = internal._children[i];\n\t\tif (childInternal) {\n\t\t\tchildInternal._parent = internal;\n\n\t\t\tif (childInternal.flags & TYPE_COMPONENT) {\n\t\t\t\tinsertComponentDom(childInternal, nextSibling, parentDom);\n\t\t\t} else if (childInternal._dom != nextSibling) {\n\t\t\t\tparentDom.insertBefore(childInternal._dom, nextSibling);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tfor (children of children) {\n\t\t\ttoChildArray(children, out);\n\t\t}\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n","import { diffChildren, insertComponentDom } from './children';\nimport { setProperty } from './props';\nimport options from '../options';\nimport { renderClassComponent, renderFunctionComponent } from './component';\nimport {\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_ELEMENT,\n\tMODE_SUSPENDED,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tTYPE_CLASS,\n\tMODE_SVG,\n\tUNDEFINED,\n\tMODE_HYDRATE,\n\tMODE_PENDING_ERROR,\n\tMODE_RERENDERING_ERROR,\n\tSKIP_CHILDREN,\n\tDIRTY_BIT\n} from '../constants';\nimport { getDomSibling, getParentContext } from '../tree';\nimport { mountChildren } from './mount';\nimport { Fragment } from '../create-element';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n */\nexport function patch(parentDom, newVNode, internal, commitQueue) {\n\tlet dom = internal._dom;\n\tlet flags = internal.flags;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (newVNode !== internal.props) {\n\t\t\tdom.data = newVNode;\n\t\t\tinternal.props = newVNode;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== UNDEFINED) return null;\n\n\tif (options._diff) options._diff(internal, newVNode);\n\n\tif (flags & TYPE_ELEMENT) {\n\t\tif (newVNode._vnodeId !== internal._vnodeId) {\n\t\t\t// @ts-ignore dom is a PreactElement here\n\t\t\tpatchDOMElement(dom, newVNode, internal, commitQueue);\n\t\t\t// Once we have successfully rendered the new VNode, copy it's ID over\n\t\t\tinternal._vnodeId = newVNode._vnodeId;\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal.flags &= RESET_MODE;\n\t}\n\n\t/** @type {import('../index').ComponentChild} */\n\tlet nextDomSibling;\n\n\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t// top.\n\tlet prevParentDom = parentDom;\n\tif (flags & TYPE_ROOT) {\n\t\tparentDom = newVNode.props._parentDom;\n\n\t\tif (internal.props._parentDom !== newVNode.props._parentDom) {\n\t\t\tlet nextSibling =\n\t\t\t\tparentDom == prevParentDom ? getDomSibling(internal) : null;\n\t\t\tinsertComponentDom(internal, nextSibling, parentDom);\n\t\t}\n\t}\n\n\ttry {\n\t\tif (internal.flags & MODE_PENDING_ERROR) {\n\t\t\t// Toggle the MODE_PENDING_ERROR and MODE_RERENDERING_ERROR flags. In\n\t\t\t// actuality, this should turn off the MODE_PENDING_ERROR flag and turn on\n\t\t\t// the MODE_RERENDERING_ERROR flag.\n\t\t\tinternal.flags ^= MODE_PENDING_ERROR | MODE_RERENDERING_ERROR;\n\t\t}\n\n\t\tconst context = getParentContext(internal);\n\n\t\t// Necessary for createContext api. Setting this property will pass\n\t\t// the context value as `this.context` just for this component.\n\t\tlet tmp = newVNode.type.contextType;\n\t\tlet provider = tmp && context[tmp._id];\n\t\tlet componentContext = tmp\n\t\t\t? provider\n\t\t\t\t? provider.props.value\n\t\t\t\t: tmp._defaultValue\n\t\t\t: context;\n\t\tlet isNew = !internal || !internal._component;\n\n\t\tif (internal.flags & TYPE_CLASS) {\n\t\t\tnextDomSibling = renderClassComponent(\n\t\t\t\tnewVNode,\n\t\t\t\tinternal,\n\t\t\t\tcontext,\n\t\t\t\tcomponentContext\n\t\t\t);\n\t\t} else {\n\t\t\tnextDomSibling = renderFunctionComponent(\n\t\t\t\tnewVNode,\n\t\t\t\tinternal,\n\t\t\t\tcontext,\n\t\t\t\tcomponentContext\n\t\t\t);\n\t\t}\n\n\t\tif (internal.flags & SKIP_CHILDREN) {\n\t\t\tinternal.props = newVNode.props;\n\t\t\tinternal.flags &= ~SKIP_CHILDREN;\n\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\tif (newVNode && newVNode._vnodeId !== internal._vnodeId) {\n\t\t\t\tinternal.flags &= ~DIRTY_BIT;\n\t\t\t}\n\t\t} else {\n\t\t\tlet isTopLevelFragment =\n\t\t\t\tnextDomSibling != null &&\n\t\t\t\tnextDomSibling.type === Fragment &&\n\t\t\t\tnextDomSibling.key == null;\n\t\t\tlet renderResult = isTopLevelFragment\n\t\t\t\t? nextDomSibling.props.children\n\t\t\t\t: nextDomSibling;\n\n\t\t\tif (internal._children == null) {\n\t\t\t\tmountChildren(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\t\tinternal,\n\t\t\t\t\tcommitQueue,\n\t\t\t\t\t(internal.flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t\t\t\t\t? internal._dom\n\t\t\t\t\t\t: isNew || internal.flags & MODE_HYDRATE\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: getDomSibling(internal)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdiffChildren(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\t\tinternal,\n\t\t\t\t\tcommitQueue\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (internal._commitCallbacks != null && internal._commitCallbacks.length) {\n\t\t\tcommitQueue.push(internal);\n\t\t}\n\t} catch (e) {\n\t\t// @TODO: assign a new VNode ID here? Or NaN?\n\t\t// newVNode._vnodeId = 0;\n\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\t\toptions._catchError(e, internal);\n\t}\n\n\tif (options.diffed) options.diffed(internal);\n\n\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\tinternal.flags &= RESET_MODE;\n\t// Once we have successfully rendered the new VNode, copy it's ID over\n\tinternal._vnodeId = newVNode._vnodeId;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n */\nfunction patchDOMElement(dom, newVNode, internal, commitQueue) {\n\tlet oldProps = internal.props,\n\t\tnewProps = (internal.props = newVNode.props),\n\t\tisSvg = internal.flags & MODE_SVG,\n\t\ti,\n\t\tvalue,\n\t\ttmp,\n\t\tnewHtml,\n\t\toldHtml,\n\t\tnewChildren;\n\n\tfor (i in oldProps) {\n\t\tvalue = oldProps[i];\n\t\tif (i === 'key') {\n\t\t} else if (i === 'children') {\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\toldHtml = value;\n\t\t} else if (!(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, value, isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tvalue = newProps[i];\n\t\tif (i === 'key') {\n\t\t} else if (i === 'children') {\n\t\t\tnewChildren = value;\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\tnewHtml = value;\n\t\t} else if (\n\t\t\tvalue !== (tmp = oldProps[i]) ||\n\t\t\t((i === 'checked' || i === 'value') && value != null && value !== dom[i])\n\t\t) {\n\t\t\tsetProperty(dom, i, value, tmp, isSvg);\n\t\t}\n\t}\n\n\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\tif (newHtml) {\n\t\tvalue = newHtml.__html;\n\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\tif (!oldHtml || (value !== oldHtml.__html && value !== dom.innerHTML)) {\n\t\t\tdom.innerHTML = value;\n\t\t}\n\t\tinternal._children = null;\n\t} else {\n\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\tdiffChildren(\n\t\t\tdom,\n\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\tinternal,\n\t\t\tcommitQueue,\n\t\t\tdom.firstChild\n\t\t);\n\t}\n\n\tif (newProps.value != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.value;\n\t} else if (newProps.checked != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.checked;\n\t}\n}\n","import { applyRef } from './refs';\nimport {\n\tTYPE_COMPONENT,\n\tTYPE_ELEMENT,\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tMODE_SVG\n} from '../constants';\nimport { normalizeToVNode, Fragment } from '../create-element';\nimport { setProperty } from './props';\nimport { renderClassComponent, renderFunctionComponent } from './component';\nimport { createInternal, getParentContext } from '../tree';\nimport options from '../options';\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom\n * @returns {import('../internal').PreactElement | null} pointer to the next DOM node to be hydrated (or null)\n */\nexport function mount(parentDom, newVNode, internal, commitQueue, startDom) {\n\tif (options._diff) options._diff(internal, newVNode);\n\n\t/** @type {import('../index').ComponentChild} */\n\tlet nextDomSibling;\n\n\ttry {\n\t\tif (internal.flags & TYPE_COMPONENT) {\n\t\t\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t\t\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t\t\t// top.\n\t\t\tlet prevStartDom = startDom;\n\t\t\tlet prevParentDom = parentDom;\n\t\t\tif (internal.flags & TYPE_ROOT) {\n\t\t\t\tparentDom = newVNode.props._parentDom;\n\n\t\t\t\tif (parentDom !== prevParentDom) {\n\t\t\t\t\tstartDom = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst context = getParentContext(internal);\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\tlet tmp = newVNode.type.contextType;\n\t\t\tlet provider = tmp && context[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: context;\n\n\t\t\tif (provider) provider._subs.add(internal);\n\n\t\t\tif (internal.flags & TYPE_CLASS) {\n\t\t\t\tnextDomSibling = renderClassComponent(\n\t\t\t\t\tnull,\n\t\t\t\t\tinternal,\n\t\t\t\t\tcontext,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tnextDomSibling = renderFunctionComponent(\n\t\t\t\t\tnull,\n\t\t\t\t\tinternal,\n\t\t\t\t\tcontext,\n\t\t\t\t\tcomponentContext\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\tnextDomSibling != null &&\n\t\t\t\tnextDomSibling.type === Fragment &&\n\t\t\t\tnextDomSibling.key == null;\n\n\t\t\tlet renderResult = isTopLevelFragment\n\t\t\t\t? nextDomSibling.props.children\n\t\t\t\t: nextDomSibling;\n\n\t\t\tnextDomSibling = mountChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tinternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tstartDom\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tinternal._commitCallbacks != null &&\n\t\t\t\tinternal._commitCallbacks.length\n\t\t\t) {\n\t\t\t\tcommitQueue.push(internal);\n\t\t\t}\n\n\t\t\tif (internal.flags & TYPE_ROOT && prevParentDom !== parentDom) {\n\t\t\t\t// If we just mounted a root node/Portal, and it changed the parentDom\n\t\t\t\t// of it's children, then we need to resume the diff from it's previous\n\t\t\t\t// startDom element, which could be null if we are mounting an entirely\n\t\t\t\t// new tree, or the portal's nextSibling if we are mounting a Portal in\n\t\t\t\t// an existing tree.\n\t\t\t\tnextDomSibling = prevStartDom;\n\t\t\t}\n\t\t} else {\n\t\t\tlet hydrateDom =\n\t\t\t\tinternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)\n\t\t\t\t\t? startDom\n\t\t\t\t\t: null;\n\n\t\t\tnextDomSibling = mountDOMElement(hydrateDom, internal, commitQueue);\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal.flags &= RESET_MODE;\n\t} catch (e) {\n\t\tinternal._vnodeId = 0;\n\t\tinternal.flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\n\t\tif (internal.flags & MODE_HYDRATE) {\n\t\t\t// @ts-ignore Trust me TS, nextSibling is a PreactElement\n\t\t\tnextDomSibling = startDom && startDom.nextSibling;\n\t\t\tinternal._dom = startDom; // Save our current DOM position to resume later\n\t\t}\n\t\toptions._catchError(e, internal);\n\t}\n\n\treturn nextDomSibling;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @returns {import('../internal').PreactElement}\n */\nfunction mountDOMElement(dom, internal, commitQueue) {\n\tlet newProps = internal.props;\n\tlet nodeType = internal.type;\n\t/** @type {any} */\n\tlet i, value;\n\n\tlet flags = internal.flags;\n\tlet isSvg = flags & MODE_SVG;\n\n\t// Are we *not* hydrating? (a top-level render() or mutative hydration):\n\tlet isFullRender = ~flags & MODE_HYDRATE;\n\n\t// if hydrating (hydrate() or render() with replaceNode), find the matching child:\n\tif (flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)) {\n\t\twhile (\n\t\t\tdom &&\n\t\t\t(nodeType ? dom.localName !== nodeType : dom.nodeType !== 3)\n\t\t) {\n\t\t\tdom = dom.nextSibling;\n\t\t}\n\t}\n\n\tlet isNew = dom == null;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (isNew) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\tdom = document.createTextNode(newProps);\n\t\t} else if (dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\n\t\tinternal._dom = dom;\n\t} else {\n\t\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\t\t// if (nodeType === 'svg') internal.flags |= MODE_SVG;\n\n\t\tif (isNew) {\n\t\t\tif (isSvg) {\n\t\t\t\tdom = document.createElementNS(\n\t\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType,\n\t\t\t\t\tnewProps.is && newProps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\t\tinternal.flags = flags &= RESET_MODE;\n\t\t\tisFullRender = 1;\n\t\t}\n\n\t\t// @TODO: Consider removing and instructing users to instead set the desired\n\t\t// prop for removal to undefined/null. During hydration, props are not\n\t\t// diffed at all (including dangerouslySetInnerHTML)\n\t\tif (flags & MODE_MUTATIVE_HYDRATE) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i].name;\n\t\t\t\tif (!(value in newProps)) {\n\t\t\t\t\tdom.removeAttribute(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet newHtml, newValue, newChildren;\n\t\tif (\n\t\t\t(internal.type === 'input' ||\n\t\t\t\tinternal.type === 'textarea' ||\n\t\t\t\tinternal.type === 'select') &&\n\t\t\t(newProps.onInput || newProps.onChange)\n\t\t) {\n\t\t\tif (newProps.value != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.value;\n\t\t\t} else if (newProps.checked != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.checked;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i === 'key') {\n\t\t\t} else if (i === 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i === 'value') {\n\t\t\t\tnewValue = value;\n\t\t\t} else if (\n\t\t\t\tvalue != null &&\n\t\t\t\t(isFullRender || typeof value === 'function')\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, null, isSvg);\n\t\t\t}\n\t\t}\n\n\t\tinternal._dom = dom;\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tif (isFullRender && newHtml.__html) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\t\t\tinternal._children = null;\n\t\t} else if (newChildren != null) {\n\t\t\tmountChildren(\n\t\t\t\tdom,\n\t\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tinternal,\n\t\t\t\tcommitQueue,\n\t\t\t\tisNew ? null : dom.firstChild\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (isFullRender && newValue != null) {\n\t\t\tsetProperty(dom, 'value', newValue, null, 0);\n\t\t}\n\t}\n\n\t// @ts-ignore\n\treturn isNew ? null : dom.nextSibling;\n}\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').Internal} parentInternal The parent Internal of the given children\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom\n */\nexport function mountChildren(\n\tparentDom,\n\trenderResult,\n\tparentInternal,\n\tcommitQueue,\n\tstartDom\n) {\n\tlet internalChildren = (parentInternal._children = []),\n\t\ti,\n\t\tchildVNode,\n\t\tchildInternal,\n\t\tnewDom,\n\t\tmountedNextChild;\n\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = normalizeToVNode(renderResult[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tinternalChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildInternal = createInternal(childVNode, parentInternal);\n\t\tinternalChildren[i] = childInternal;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tmountedNextChild = mount(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\tchildInternal,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childInternal.flags & TYPE_COMPONENT || newDom == startDom) {\n\t\t\t// If the child is a Fragment-like or if it is DOM VNode and its _dom\n\t\t\t// property matches the dom we are diffing (i.e. startDom), just\n\t\t\t// continue with the mountedNextChild\n\t\t\tstartDom = mountedNextChild;\n\t\t} else if (newDom != null) {\n\t\t\t// The DOM the diff should begin with is now startDom (since we inserted\n\t\t\t// newDom before startDom) so ignore mountedNextChild and continue with\n\t\t\t// startDom\n\t\t\tparentDom.insertBefore(newDom, startDom);\n\t\t}\n\n\t\tif (childInternal.ref) {\n\t\t\tapplyRef(\n\t\t\t\tnull,\n\t\t\t\tchildInternal.ref,\n\t\t\t\tchildInternal._component || newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode.\n\tif (\n\t\tparentInternal.flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE) &&\n\t\tparentInternal.flags & TYPE_ELEMENT\n\t) {\n\t\t// TODO: Would it be simpler to just clear the pre-existing DOM in top-level\n\t\t// render if render is called with no oldVNode & existing children & no\n\t\t// replaceNode? Instead of patching the DOM to match the VNode tree? (remove\n\t\t// attributes & unused DOM)\n\t\twhile (startDom) {\n\t\t\ti = startDom;\n\t\t\tstartDom = startDom.nextSibling;\n\t\t\ti.remove();\n\t\t}\n\t}\n\n\treturn startDom;\n}\n","import {\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { commitRoot } from './diff/commit';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { mount } from './diff/mount';\nimport { patch } from './diff/patch';\nimport { createInternal } from './tree';\n\n/**\n *\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * @returns {import('./internal').Root}\n */\nexport function createRoot(parentDom) {\n\tlet rootInternal,\n\t\tcommitQueue,\n\t\tfirstChild,\n\t\tflags = 0;\n\n\tfunction render(vnode) {\n\t\tif (options._root) options._root(vnode, parentDom);\n\n\t\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\n\t\tfirstChild =\n\t\t\t/** @type {import('./internal').PreactElement} */ (parentDom.firstChild);\n\n\t\t// List of effects that need to be called after diffing:\n\t\tcommitQueue = [];\n\n\t\tif (rootInternal) {\n\t\t\tpatch(parentDom, vnode, rootInternal, commitQueue);\n\t\t} else {\n\t\t\trootInternal = createInternal(vnode);\n\n\t\t\t// Store the VDOM tree root on the DOM element in a (minified) property:\n\t\t\tparentDom._children = rootInternal;\n\n\t\t\t// Calling createRoot().render() on an Element with existing children triggers mutative hydrate mode:\n\t\t\tif (firstChild) {\n\t\t\t\tflags = flags || MODE_MUTATIVE_HYDRATE;\n\t\t\t}\n\t\t\t// If the parent of this tree is within an inline SVG, the tree should start off in SVG mode:\n\t\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\t\tflags |= MODE_SVG;\n\t\t\t}\n\t\t\trootInternal.flags |= flags;\n\n\t\t\trootInternal._context = {};\n\n\t\t\tmount(parentDom, vnode, rootInternal, commitQueue, firstChild);\n\t\t}\n\n\t\t// Flush all queued effects\n\t\tcommitRoot(commitQueue, rootInternal);\n\t}\n\n\treturn {\n\t\thydrate(vnode) {\n\t\t\tflags |= MODE_HYDRATE;\n\t\t\trender(vnode);\n\t\t},\n\t\trender\n\t};\n}\n","import { createElement } from './create-element';\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\treturn props.children;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\t// Note: We can't use Fragment here because a component that returned a Portal\n\t// (e.g. `const App = () => createPortal(...)`) wouldn't work. Our diff\n\t// collapses Fragments without keys that are returned directly from components\n\t// into just an array and sets that as the children array of the component.\n\t//\n\t// We also can't use keyed Fragments here cuz it might lead to weird edge\n\t// cases when toggling between two sibling portals if we use a shared keyed or\n\t// lead to unnecessary re-mounts if trying to generate a new key on each call.\n\t//\n\t// So the simplest solution seems to be just to use an unique type for Portal\n\t// to skip the Fragment collapsing logic when diffing components\n\treturn createElement(Portal, { _parentDom: container }, vnode);\n}\n","import {\n\tDIRTY_BIT,\n\tMODE_RERENDERING_ERROR,\n\tMODE_PENDING_ERROR,\n\tTYPE_COMPONENT\n} from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').Internal} internal The Internal node that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, internal) {\n\twhile ((internal = internal._parent)) {\n\t\tif (\n\t\t\tinternal.flags & TYPE_COMPONENT &&\n\t\t\t~internal.flags & MODE_RERENDERING_ERROR\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (internal.type.getDerivedStateFromError) {\n\t\t\t\t\tinternal._component.setState(\n\t\t\t\t\t\tinternal.type.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (internal._component.componentDidCatch) {\n\t\t\t\t\tinternal._component.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\t// NOTE: We're checking that any component in the stack got marked as dirty, even if it did so prior to this loop,\n\t\t\t\t// which is technically incorrect. However, there is no way for a component to mark itself as dirty during rendering.\n\t\t\t\t// The only way for a component to falsely intercept error bubbling would be to manually sets its internal dirty flag.\n\t\t\t\tif (internal.flags & DIRTY_BIT) {\n\t\t\t\t\tinternal.flags |= MODE_PENDING_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = Object.assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\t0\n\t);\n}\n","import { createRoot } from './create-root';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.render(vnode);\n\tparentDom._root = root;\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tlet root = parentDom && parentDom._root;\n\tif (!root) {\n\t\troot = createRoot(parentDom);\n\t}\n\troot.hydrate(vnode);\n\tparentDom._root = root;\n}\n"],"names":["options","vnodeId","isValidElement","nextContextId","providers","unsubscribeFromContext","createContext","rerenderQueue","prevDebounce","defer","len","shouldSearchComponent","TYPE_ROOT","TYPE_COMPONENT","TYPE_CLASS","MODE_SVG","DIRTY_BIT","SKIP_CHILDREN","RESET_MODE","EMPTY_ARR","UNDEFINED","undefined","addCommitCallback","internal","callback","push","commitRoot","commitQueue","rootInternal","some","length","shift","e","createElement","type","props","children","key","ref","i","normalizedProps","arguments","createVNode","original","vnode","constructor","__v","normalizeToVNode","childVNode","Array","isArray","Fragment","applyRef","oldRef","value","current","setStyle","dom","style","setProperty","name","oldValue","isSvg","useCapture","o","replace","toLowerCase","slice","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","setAttribute","removeAttribute","this","event","_isControlled","_prevValue","checked","renderFunctionComponent","newVNode","context","componentContext","c","tmp","newProps","forceUpdate","rerender","bind","flags","call","getChildContext","Object","assign","renderClassComponent","isNew","oldProps","oldState","snapshot","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","render","getSnapshotBeforeUpdate","componentDidUpdate","unmount","parentInternal","skipRemove","r","componentWillUnmount","TYPE_TEXT","remove","diffChildren","parentDom","renderResult","newDom","refs","childInternal","oldVNodeRef","skewedIndex","matchingIndex","mountingChild","nextSibling","oldChildren","oldChildrenLength","remainingOldChildren","skew","newChildren","findMatchingIndex","mount","createInternal","getDomSibling","patch","go","insertBefore","insertComponentDom","match","x","y","oldChild","nextDomSibling","prevParentDom","provider","data","patchDOMElement","diffed","MODE_PENDING_ERROR","getParentContext","contextType","mountChildren","then","newHtml","oldHtml","innerHTML","Component","enqueueRender","process","debounceRendering","sort","a","b","getParentDom","MODE_HYDRATE","NaN","prototype","__k","__","__e","__c","__b","childIndex","indexOf","getChildDom","child","childDom","parent","startDom","prevStartDom","add","mountDOMElement","newValue","nodeType","isFullRender","localName","document","createTextNode","createElementNS","is","attributes","onInput","onChange","firstChild","mountedNextChild","internalChildren","createRoot","__P","ownerSVGElement","hydrate","Portal","error","getDerivedStateFromError","setState","componentDidCatch","Set","delete","forEach","p","defaultValue","contextId","Consumer","contextValue","Provider","ctx","update","s","Promise","resolve","container","root","toChildArray","out"],"mappings":"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"}