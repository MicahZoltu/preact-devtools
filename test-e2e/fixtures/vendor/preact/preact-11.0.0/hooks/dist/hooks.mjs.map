{"version":3,"file":"hooks.mjs","sources":["../src/index.js","../../src/component.js","../../src/tree.js","../../src/constants.js"],"sourcesContent":["import { options } from 'preact';\nimport { getParentContext } from '../../src/tree';\nimport { MODE_UNMOUNTING } from '../../src/constants';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Internal} */\nlet currentInternal;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._diff = (internal, vnode) => {\n\tcurrentInternal = null;\n\tif (oldBeforeDiff) oldBeforeDiff(internal, vnode);\n};\n\noptions._render = internal => {\n\tif (oldBeforeRender) oldBeforeRender(internal);\n\n\tcurrentInternal = internal;\n\tcurrentIndex = 0;\n\n\tif (currentInternal.data && currentInternal.data.__hooks) {\n\t\tcurrentInternal.data.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\tcurrentInternal.data.__hooks._pendingEffects.forEach(invokeEffect);\n\t\tcurrentInternal.data.__hooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = internal => {\n\tif (oldAfterDiff) oldAfterDiff(internal);\n\n\tif (\n\t\tinternal.data &&\n\t\tinternal.data.__hooks &&\n\t\tinternal.data.__hooks._pendingEffects.length\n\t) {\n\t\tafterPaint(afterPaintEffects.push(internal));\n\t}\n};\n\noptions._commit = (internal, commitQueue) => {\n\tcommitQueue.some(internal => {\n\t\ttry {\n\t\t\tinternal._commitCallbacks.forEach(invokeCleanup);\n\t\t\tinternal._commitCallbacks = internal._commitCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(i => {\n\t\t\t\tif (i._commitCallbacks) i._commitCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(internal, commitQueue);\n};\n\noptions.unmount = internal => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(internal);\n\n\tif (internal.data && internal.data.__hooks) {\n\t\tlet hasErrored;\n\t\tinternal.data.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tif (hasErrored) options._catchError(hasErrored, internal);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentInternal, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentInternal.data.__hooks ||\n\t\t(currentInternal.data.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} [initialState]\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._internal) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._internal.rerender(hookState._internal);\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._internal = currentInternal;\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentInternal.data.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tif (currentInternal._commitCallbacks == null) {\n\t\t\tcurrentInternal._commitCallbacks = [];\n\t\t}\n\t\tcurrentInternal._commitCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = getParentContext(currentInternal)[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider._subs.add(currentInternal);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nconst oldCatchError = options._catchError;\n// TODO: this double traverses now in combination with the root _catchError\n// however when we split Component up this shouldn't be needed\n// there can be a better solution to this if we just do a single iteration\n// as a combination of suspsense + hooks + component (compat) would be 3 tree-iterations\noptions._catchError = function(error, internal) {\n\t/** @type {import('./internal').Component} */\n\tlet handler = internal;\n\tfor (; (handler = handler._parent); ) {\n\t\tif (handler.data && handler.data._catchError) {\n\t\t\treturn handler.data._catchError(error, internal);\n\t\t}\n\t}\n\n\toldCatchError(error, internal);\n};\n\n/**\n * @param {(error: any) => void} cb\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\n\tif (!currentInternal.data._catchError) {\n\t\tcurrentInternal.data._catchError = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet internal;\n\tafterPaintEffects.sort((a, b) => a._depth - b._depth);\n\twhile ((internal = afterPaintEffects.pop())) {\n\t\tif (~internal.flags & MODE_UNMOUNTING) {\n\t\t\ttry {\n\t\t\t\tinternal.data.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tinternal.data.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tinternal.data.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tinternal.data.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, internal);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentInternal away.\n\tconst internal = currentInternal;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\tcurrentInternal = internal;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentInternal away.\n\tconst internal = currentInternal;\n\thook._cleanup = hook._value();\n\tcurrentInternal = internal;\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n","import { addCommitCallback, commitRoot } from './diff/commit';\nimport options from './options';\nimport { createVNode, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport { DIRTY_BIT, FORCE_UPDATE, MODE_UNMOUNTING } from './constants';\nimport { getParentDom } from './tree';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._internal) {\n\t\tif (callback) addCommitCallback(this._internal, callback.bind(this));\n\t\tthis._internal.rerender(this._internal);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._internal.flags |= FORCE_UPDATE;\n\t\tif (callback) addCommitCallback(this._internal, callback.bind(this));\n\t\tthis._internal.rerender(this._internal);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nfunction rerender(internal) {\n\tif (~internal.flags & MODE_UNMOUNTING && internal.flags & DIRTY_BIT) {\n\t\tlet parentDom = getParentDom(internal);\n\n\t\tconst vnode = createVNode(\n\t\t\tinternal.type,\n\t\t\tinternal.props,\n\t\t\tinternal.key, // @TODO we shouldn't need to actually pass these\n\t\t\tinternal.ref, // since the mode flag should bypass key/ref handling\n\t\t\t0\n\t\t);\n\n\t\tconst commitQueue = [];\n\t\tpatch(parentDom, vnode, internal, commitQueue);\n\t\tcommitRoot(commitQueue, internal);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Internal>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of an internal\n * @param {import('./internal').Internal} internal The internal to rerender\n */\nexport function enqueueRender(internal) {\n\tif (\n\t\t(!(internal.flags & DIRTY_BIT) &&\n\t\t\t(internal.flags |= DIRTY_BIT) &&\n\t\t\trerenderQueue.push(internal) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\twhile ((len = process._rerenderCount = rerenderQueue.length)) {\n\t\trerenderQueue.sort((a, b) => a._depth - b._depth);\n\t\twhile (len--) {\n\t\t\trerender(rerenderQueue.shift());\n\t\t}\n\t}\n}\nlet len = (process._rerenderCount = 0);\n","import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { enqueueRender } from './component';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal.flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals use NaN as an ID so that two are never equal.\n\tlet vnodeId = NaN;\n\n\tif (typeof vnode === 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t} else if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props || {};\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type === 'function'\n\t\t\t\t? type.prototype && 'render' in type.prototype\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal.flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tdata: typeof type == 'function' ? {} : null,\n\t\trerender: enqueueRender,\n\t\tflags,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_dom: null,\n\t\t_component: null,\n\t\t_context: null,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal.flags & TYPE_COMPONENT &&\n\t(!(internal.flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} [i]\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, i) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (i = i || 0; i < internal._children.length; i++) {\n\t\tlet child = internal._children[i];\n\t\tif (child != null) {\n\t\t\tif (child.flags & TYPE_DOM) {\n\t\t\t\treturn child._dom;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n/**\n * @param {import('./internal').Internal} internal\n * @returns {any}\n */\nexport function getParentContext(internal) {\n\tlet context = internal._context;\n\tlet parent = internal._parent;\n\twhile (context == null && parent) {\n\t\tcontext = parent._context;\n\t\tparent = parent._parent;\n\t}\n\n\treturn context;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parentDom = internal.flags & TYPE_ROOT ? internal.props._parentDom : null;\n\n\tlet parent = internal._parent;\n\twhile (parentDom == null && parent) {\n\t\tif (parent.flags & TYPE_ROOT) {\n\t\t\tparentDom = parent.props._parentDom;\n\t\t} else if (parent.flags & TYPE_ELEMENT) {\n\t\t\tparentDom = parent._dom;\n\t\t}\n\n\t\tparent = parent._parent;\n\t}\n\n\treturn parentDom;\n}\n","// Internal.flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n/** Signals the component can skip children due to a non-update */\nexport const SKIP_CHILDREN = 1 << 15;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE |\n\tSKIP_CHILDREN\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n"],"names":["currentIndex","currentInternal","Promise","prototype","then","bind","resolve","prevRaf","currentHook","afterPaintEffects","oldBeforeDiff","options","oldBeforeRender","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","data","__","__h","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","rerender","useEffect","callback","args","state","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","current","useImperativeHandle","ref","createHandle","concat","factory","useCallback","useContext","context","provider","internal","parent","getParentContext","add","props","value","useDebugValue","formatter","vnode","forEach","invokeCleanup","invokeEffect","requestAnimationFrame","afterNextFrame","flushAfterPaintEffects","commitQueue","some","filter","cb","e","i","hasErrored","s","oldCatchError","useErrorBoundary","errState","err","sort","a","b","pop","flags","error","handler","HAS_RAF","done","clearTimeout","timeout","cancelAnimationFrame","raf","setTimeout","hook","cleanup","oldArgs","newArgs","arg","f"],"mappings":"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"}