import{Fragment as t,options as e,Component as n}from"preact";import{MODE_UNMOUNTING as o}from"preact/src/constants";import{IS_NON_DIMENSIONAL as r}from"preact/compat/src/util";import"preact/devtools";let i={};function a(){i={}}function s(e){return e.type===t?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}let c=[],l=[];function p(){return c.length>0?c[c.length-1]:null}let u=!1;function d(e){return"function"==typeof e.type&&e.type!=t}function f(t){const e=[t];let n=t;for(;null!=n.__o;)e.push(n.__o),n=n.__o;return e.reduce((t,e)=>{t+=`  in ${s(e)}`;const n=e.props&&e.props.__source;return n?t+=` (at ${n.fileName}:${n.lineNumber})`:u||(u=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),t+"\n"},"")}const h="function"==typeof WeakMap;function m(t){return t?"function"==typeof t.type?m(t.__):t:{}}const y=n.prototype.setState;n.prototype.setState=function(t,e){return null==this.__i?null==this.state&&console.warn(`Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n${f(p())}`):this.__i.flags&o&&console.warn(`Can't call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n${f(this.__i)}`),y.call(this,t,e)};const b=n.prototype.forceUpdate;function $(t){let{props:e}=t,n=s(t),o="";for(let t in e)if(e.hasOwnProperty(t)&&"children"!==t){let n=e[t];"function"==typeof n&&(n=`function ${n.displayName||n.name}() {}`),n=Object(n)!==n||n.toString?n+"":Object.prototype.toString.call(n),o+=` ${t}=${JSON.stringify(n)}`}let r=e.children;return`<${n}${o}${r&&r.length?">..</"+n+">":" />"}`}n.prototype.forceUpdate=function(t){return null==this.__i?console.warn(`Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n${f(p())}`):this.__i.flags&o&&console.warn(`Can't call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n${f(this.__i)}`),b.call(this,t)},function(){!function(){let t=e.__b,n=e.diffed,o=e.__,r=e.vnode,i=e.__i,a=e.__r;e.diffed=t=>{d(t)&&l.pop(),c.pop(),n&&n(t)},e.__b=(e,n)=>{d(e)&&c.push(e),t&&t(e,n)},e.__=(t,e)=>{l=[],o&&o(t,e)},e.vnode=t=>{t.__o=l.length>0?l[l.length-1]:null,r&&r(t)},e.__i=(t,e)=>{null!==t.type&&(t.__o=e.__o),i&&i(t,e)},e.__r=t=>{d(t)&&l.push(t),a&&a(t)}}();let t=!1,n=e.__b,o=e.diffed,a=e.vnode,p=e.__e,u=e.__,y=e.__h;const b=h?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,w=[];e.__e=(t,e,n)=>{if(e&&e.__c&&"function"==typeof t.then){const n=t;t=new Error(`Missing Suspense. The throwing component was: ${s(e)}`);let o=e;for(;o;o=o.__)if(o.__c&&o.__c.__c){t=n;break}if(t instanceof Error)throw t}try{p(t,e,n),"function"!=typeof t.then&&setTimeout(()=>{throw t})}catch(t){throw t}},e.__=(t,e)=>{if(!e)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");let n;switch(e.nodeType){case 1:case 11:case 9:n=!0;break;default:n=!1}if(!n){let n=s(t);throw new Error(`Expected a valid HTML node as a second argument to render.\tReceived ${e} instead: render(<${n} />, ${e});`)}u&&u(t,e)},e.__b=(e,o)=>{if(null===o||"object"!=typeof o)return;if(void 0!==o.constructor){const t=Object.keys(o).join(",");throw new Error(`Objects are not valid as a child. Encountered an object with the keys {${t}}.\n\n${f(e)}`)}let{type:a,__:c}=e;if(void 0===a)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+$(o)+`\n\n${f(e)}`);if(null!=a&&"object"==typeof a){if(void 0===a.constructor)throw new Error(`Invalid type passed to createElement(): ${a}\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My${s(e)} = ${$(a)};\n  let vnode = <My${s(e)} />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n${f(e)}`);throw new Error("Invalid type passed to createElement(): "+(Array.isArray(a)?"array":a))}let l=m(c);t=!0,"thead"!==a&&"tfoot"!==a&&"tbody"!==a||"table"===l.type?"tr"===a&&"thead"!==l.type&&"tfoot"!==l.type&&"tbody"!==l.type&&"table"!==l.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+$(e)+`\n\n${f(e)}`):"td"===a&&"tr"!==l.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+$(e)+`\n\n${f(e)}`):"th"===a&&"tr"!==l.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+$(e)+`\n\n${f(e)}`):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+$(e)+`\n\n${f(e)}`);let p="$$typeof"in o;if(void 0!==e.ref&&"function"!=typeof e.ref&&"object"!=typeof e.ref&&!p)throw new Error(`Component's "ref" property should be a function, or an object created by createRef(), but got [${typeof e.ref}] instead\n`+$(e)+`\n\n${f(e)}`);if("string"==typeof e.type)for(const t in o.props){if("o"===t[0]&&"n"===t[1]&&"function"!=typeof o.props[t]&&null!=o.props[t])throw new Error(`Component's "${t}" property should be a function, but got [${typeof o.props[t]}] instead\n`+$(o)+`\n\n${f(e)}`);if(!p&&"style"===t&&null!==o.props[t]&&"object"==typeof o.props[t]){const e=o.props[t];for(let t in e)"number"!=typeof e[t]||r.test(t)||console.warn(`Numeric CSS property value is missing a "px" unit: ${t}: ${e[t]}"\n`+$(o)+`\n\n${f(o)}`)}}if("function"==typeof e.type&&e.type.propTypes){if("Lazy"===e.type.displayName&&b&&!b.lazyPropTypes.has(e.type)){const t="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{const n=e.type();b.lazyPropTypes.set(e.type,!0),console.warn(t+`Component wrapped in lazy() is ${s(n)}`)}catch(e){console.warn(t+"We will log the wrapped component's name once it is loaded.")}}let t=o?o.props:e.props;e.type.__f&&(t=Object.assign({},t),delete t.ref),function(t,e,n,o,r){Object.keys(t).forEach(n=>{let a;try{a=t[n](e,n,o,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(t){a=t}a&&!(a.message in i)&&(i[a.message]=!0,console.error(`Failed prop type: ${a.message}${r&&`\n${r()}`||""}`))})}(e.type.propTypes,t,0,s(e),()=>f(e))}n&&n(e,o)},e.__h=(e,n,o)=>{if(!e||!t)throw new Error("Hook can only be invoked from render methods.");y&&y(e,n,o)};const g=(t,e)=>({get(){const n="get"+t+e;w&&w.indexOf(n)<0&&(w.push(n),console.warn(`getting vnode.${t} is deprecated, ${e}`))},set(){const n="set"+t+e;w&&w.indexOf(n)<0&&(w.push(n),console.warn(`setting vnode.${t} is not allowed, ${e}`))}}),v={nodeName:g("nodeName","use vnode.type"),attributes:g("attributes","use vnode.props"),children:g("children","use vnode.props.children")},E={__source:{enumerable:!1},__self:{enumerable:!1}},_=Object.create({},v);e.vnode=t=>{const e=t.props;null!=e&&("__source"in e||"__self"in e)&&(Object.defineProperties(e,E),t.__source=e.__source,t.__self=e.__self),t.__proto__=_,a&&a(t)},e.diffed=e=>{if(t=!1,o&&o(e),null!=e.__k){const t=[];for(let n=0;n<e.__k.length;n++){const o=e.__k[n];if(!o||null==o.key)continue;const r=o.key;if(-1!==t.indexOf(r)){console.error(`Following component has two or more children with the same key attribute: "${r}". This may cause glitches and misbehavior in rendering process. Component: \n\n`+$(e)+`\n\n${f(e)}`);break}t.push(r)}}}}();export{a as resetPropWarnings};
//# sourceMappingURL=debug.mjs.map
